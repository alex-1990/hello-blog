title: 深究浏览器长整型数值精度丢失问题
show: true
date: 2017-07-05 14:06:36
tags: [js,java,精度丢失,数值]
categories: 技术人生
---

> `alert(28443422041709109)`会输出什么？

# 背景
在[上一篇博文](/2017/06/06/js-max-number/)里我记录了一个诡异的前后端数据不一致的问题，最终定位为前端js精度丢失。但只说了原因及结论并没有深入研究这个问题。
这一篇博文准备在此基础上，深入探寻一番，彻底弄清楚这个问题发生的本质。

# 引子
让我们先来看几个小问题热热身：
```
## js环境下运行,输出结果是什么？
1. console.log(1 === 1.0);

2. console.log(0.1 + 0.2 === 0.3);

3. console.log(9007199254740992);

4. console.log(9007199254740992 + 1);

5. console.log(9007199254740992 + 2);

6. console.log(9007199254740992 + 3);

7. console.log(9007199254740992 + 4);
... ...
```
浏览器环境下运行下看看是不是有点颠覆了三观？

<!--more-->

# JS数值的基础知识
在JS中，所有数值都是以64位浮点数形式保存的，所以1和1.0是相同的，是同一个数值。
浮点数不是精确的数值，也正因为次，`0.1+0.2`才不等于`0.3`。

根据浮点数表示的标准：
```
第1位：符号位，0表示正数，1表示负数
第2-12位：指数部分
第13-64位：小数部分（即有效数字）
```
符号位决定了正负，指数决定了数值大小，小数决定了精度。

## 精度范围
其中有效数字第一位默认总是1，不保存在64位浮点数之中，也就是说有效数字总是`1.xxx..`的形式，最长可能为52位。加上默认的1，js中提供的有效数字最长为53个二进制位。
JS中数值浮点数表示形式公式为：
```
(-1)^符号位 * 1.xxx... * 2^指数位
```

因此精度最多只能表示到53个二进制位，即`-(2^53 - 1) ~ 2^53 - 1`。超过该范围的数值不能被精确表示。

## 数值范围
指数部分11位，最大值为2047（2^11 - 1），则数值范围为`2^-1023 ~ 2^1024`，超过该范围则无法表示。

# 分析问题
了解了JS中数值表示的方法后，我们回过头来分析具体的问题。
引言中`alert(28443422041709109)`为什么会输出`28443422041709108`呢？
转换为2进制为`1100101000011010010010001000010111111100001101000110100`，因为有效位数大于53位后之后的数字都会被舍为0，因此28443422041709109的二进制表示跟28443422041709108一样。

# 结论&解决方案
后端Long整型数字如果需要和前端交互时，如果有效位数超过了前端JS可以精确表示的范围会造成精度丢失导致产生奇怪的问题。
所以如果在操作小数时可以先将小数扩大相应倍数成整数，操作后的结果再缩小相应倍数。
如果是大整数操作，建议使用String类型代替Long。

有时候项目中使用的类库中定义了Long型的大整数，由于封装特性我们没法直接修改，在跟前端交互时，吐出的数据一定要转为String返回给浏览器。目前只有交易订单号超过了位数，在处理订单号时一定要注意返回给浏览器时要将Long型转为String。
